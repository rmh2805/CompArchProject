Fetch:
    if PC == <PC MAX>, goto halt    # Halt on overflow

    Mar <- PC, PC <- PC + 1         # Prepare to pull in the next instr byte, increment PC
    IR <- Mem[MAR], <No OP>         # Grab the next opcode
    <No Op>, goto FetchOperands     # Fetch the operands for this instruction

FetchOperands:
    //if val(IR) in noOps, goto Decode      # Decode the instruction if it takes no operations
    
    # Grab the first operand
    uRet <- uPC + 1, goto GetOperand        # Micro function call
    OP1Type <- uR0, OP1Val <- uR1           # Store the type bytes & value bytes for the first operand
    OPScale1 <- uR2 << 16, <No OP>          # Store the scale bytes for the first operand
    
    if OP1Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    //if val(IR) in oneOp, goto Decode      # Break loop if this is the last operand
    
    # Grab the second operand
    uRet <- uPC + 1, goto GetOperand        # Micro function call
    OP2Type <- uR0, OP2Val <- uR1           # Store the type bytes & value bytes for the second operand
    OPScale1 <- uR2 | OPScale1, <No OP>     # Store the scale bytes for the second operand
    
    if OP1Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    //if val(IR) in twoOp, goto Decode      # Break loop if this is the last operand
    
    # Grab the third operand
    uRet <- uPC + 1, goto GetOperand        # Micro function call
    OP3Type <- uR0, OP3Val <- uR1           # Store the type bytes & value bytes for the third operand
    OPScale2 <- uR2 << 16, <No OP>          # Store the scale bytes for the third operand
    
    if OP1Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    //if val(IR) in threeOp, goto Decode    # Break loop if this is the last operand
    
    # Grab the fourth operand
    uRet <- uPC + 1, goto GetOperand        # Micro function call
    OP4Type <- uR0, OP4Val <- uR1           # Store the type bytes & value bytes for the fourth operand
    OPScale2 <- uR2 | OPScale2, <No OP>     # Store the scale bytes for the fourth operand
    
    <No OP>, goto Decode                    # Max Nr of operands grabbed, decode

InterpOperand:
    // todo

Decode:
    // todo

# This microfunction will return the next operand from memory
# Returns:
#   uR0: Returns op type and prefix bytes. LSB is always the base operand type. 
#        For displacement operand, MSB is the register specifier byte (or 0). 2 
#        prefix bytes returned in displacement operands, 3 otherwise.
#
#   uR1: Returns the op value. Either immediate or register byte. For index 
#        operand, byte order is `<null> <null> <reg byte 1> <reg byte 2>`.
#
#   uR2: Returns any scale bytes (scale operand byte followed by scale reg byte).
#        Null if not a scaled operand.
#        
GetOperand:
    uR0 <- 0, uR1 <- 0                  # Clear the return registers
    uR2 <- 0, <No OP>

GetOpType:
    if PC == <PC MAX>, goto halt        # Halt on PC overflow
    
    MAR <- PC, PC + 1                   # Prepare to pull in the next op byte, increment PC
    MDR <- Mem[MAR], uR0 <- uR0 << 8    # Pull next op byte, move back prefixes
    uR0 <- uR0 | MDR, <No OP>           # Insert next type byte into type buffer
    
    if MDR != 0, goto GetOpType2        # Skip if not operand terminator
    if uR0 != 0, goto halt              # Halt on Illegal operand (prefix bytes on an opcode terminator)
    uPC <- uRet, <No OP>                # Return since this is a legal terminator encoding
    
GetOpType2:
    if MDR & 0xF0 == 0, goto GetOpType  # If this was a prefix byte, grab the next byte
    <No OP>, goto FetchOpVal            # Else, decode the operand type

FetchOpVal:
    # Break out to second stage fetch
    if MDR & 0xF0 == 0x10, goto FetchOpRet  # No more work to be done  (nybble immediate)
    
    if MDR & 0xF0 == 0x20, goto FetchOpImm  # Fetch the immediate data (for immediate value)
    if MDR & 0xF0 == 0x50, goto FetchOpImm  # Fetch the immediate data (for the pointer address)
    if MDR & 0xF0 == 0x80, goto FetchOpImm  # Fetch the immediate data (for absolute address)
    
    if MDR & 0xF0 == 0x30, goto FetchOpReg  # Fetch the register data  (for register value)
    if MDR & 0xF0 == 0x40, goto FetchOpReg  # Fetch the register data  (for indirect access)
    if MDR & 0xF0 == 0x90, goto FetchOpReg  # Fetch the register data  (for increment access) 
    if MDR & 0xF0 == 0xA0, goto FetchOpReg  # Fetch the register data  (for decrement access)
    
    if MDR & 0xF0 == 0x60, goto FetchOpIdx  # Fetch an index operand
    if MDR & 0xF0 == 0x70, goto FetchOpDsp  # Fetch a displacement operand
    if MDR & 0xF0 == 0xB0, goto FetchOpScl  # Fetch a scale operand
    
    <No OP>, goto halt                      # Halt on Invalid address mode

FetchOpRet:
    uPC <- uRet, <No OP>                # Return (No further data to grab)

FetchOpImm:
    uCnt <- MDR & 0x03, <No OP>         # Set the immediate width counter

FetchOpImmLoop:
    
    if PC == <PC MAX>, goto halt        # Halt on PC overflow
    MAR <- PC, PC <- PC + 1             # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 8    # Grab next byte and prepare space for return
    uR1 <- uR1 | MDR, <No OP>           # Incorporate IMM byte into return

    if uCnt == 0, goto FetchOpRet       # Return on zero counter, else loop
    uCnt <- uCnt - 1, goto FetchOpImmLoop

FetchOpReg:
    # Skip grabbing the second byte if it isn't specified
    if MDR & 0x0C == 3, goto FetchOpReg2
    uPC <- uRet, <No OP>                # Return

FetchOpReg2:
    if PC == <PC MAX>, goto halt        # Halt on PC overflow
    MAR <- PC, PC <- PC + 1             # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 8    # Grab next byte and prepare space for return
    uR1 <- uR1 | MDR, <No OP>           # Incorporate IMM byte into return
    
    uPC <- uRet, <No OP>                # Return

FetchOpIdx:
    uPC <- uRet, <No OP>                # Return

FetchOpDsp:
    uPC <- uRet, <No OP>                # Return

FetchOpScl:
    uPC <- uRet, <No OP>                # Return

