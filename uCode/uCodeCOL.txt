Micro Execution RTL for COL

JMP:
    PC <- OP1Val, goto Writeback

JAL:
   MAR <- pS - 4, <No Op>
   Mem[MAR] <- pB, <No Op>
   pB <- pS - 4, <No Op>
   MAR <- pS - 8, <No Op>
   Mem[MAR] <- pR, pS <- pS - 8 
   pR <- PC, <No Op>
   PC <- dst, goto Writeback

RET:
   PC <- pR, MAR <- pB - 4
   MDR <- Mem[MAR], <No Op>
   pR <- MDR, <No Op>
   MAR <- pB + 4, <No Op>
   MDR <- Mem[MAR], <No Op>
   pS <- MDR, <No Op>
   MAR <- pB, <No Op>
   MDR <- Mem[MAR], <No Op>
   pB <- MDR, goto Writeback

BEQ:
    uTmp <- OP1Val - OP2Val, <No OP>
    if uTmp != 0, goto Writeback
    PC <- OP3Val, goto Writeback

BNE:
    uTmp <- OP1Val - OP2Val, <No OP>
    if uTmp == 0, goto Writeback
    PC <- OP3Val, goto Writeback

BGT:
    uTmp <- OP2Val - OP1Val, <No Op>    # uTmp <- src2 - src1
    uTmp <- uTmp >> 24, <No Op>         # Retain the high byte of uTmp

    if uTmp & 0x80 != 0x80, goto Writeback
    PC <- OP3Val, goto Writeback

BGE:
    uTmp <- OP1Val - OP2Val, <No Op>    # uTmp <- src1 - src2
    uTmp <- uTmp >> 24, <No Op>         # Retain the high byte of uTmp

    if uTmp & 0x80 == 0x80, goto Writeback
    PC <- OP3Val, goto Writeback

BIE:
    <No Op>, uTmp <- OP1Val + 1         # Compute the basic increment
    uR0 <- uTmp, uTmp <- uTmp - OP2Val  # Save the incremented value and compare with src2
    
    if uTmp != 0, goto Writeback
    PC <- OP3Val, goto Writeback


BDE:
    <No Op>, uTmp <- OP1Val - 1         # Compute the basic decrement
    uR0 <- uTmp, uTmp <- uTmp - OP2Val  # Save the decremented value and compare with src2
    
    if uTmp != 0, goto Writeback
    PC <- OP3Val, goto Writeback

BAO:
   <No Op>, uTmp <- ALU.OVERFLOW
   if uTmp != 1, goto Writeback
   PC <- OP1Val, goto Writeback

BAC:
   <No Op>, uTmp <- ALU.CARRY
   if uTmp != 1, goto Writeback
   PC <- OP1Val, goto Writeback

