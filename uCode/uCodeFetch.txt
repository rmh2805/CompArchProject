Fetch:
    <No OP>, <No OP>                        # Space to ensure that uPC can start before first instruction
    IncPC, IncPC                            # Halt on PC overflow, else increment
    
    MAR <- PC, <No OP>                      # Prepare to pull in the next instr byte
    MDR <- Mem[MAR], <No OP>                # Grab the next opcode
    IR <- MDR, goto FetchOperands           # Fetch the operands for this instruction

FetchOperands:
    if IR in noOps, goto Decode             # Decode the instruction if it takes no operations
    
    # Grab the first operand
    uRet <- uPC, goto GetOperand            # Micro function call
    OP1Type <- uR0, OP1Val <- uR1           # Store the type bytes & value bytes for the first operand
    OP1Scale <- uR2, <No OP>                # Store the scale bytes for the first operand
    
    if OP1Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    if IR in oneOp, goto Decode             # Break loop if this is the last operand
    
    # Grab the second operand
    uRet <- uPC, goto GetOperand            # Micro function call
    OP2Type <- uR0, OP2Val <- uR1           # Store the type bytes & value bytes for the second operand
    OP2Scale <- uR2, <No OP>                # Store the scale bytes for the second operand
    
    if OP2Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    if IR in twoOps, goto Decode            # Break loop if this is the last operand
    
    # Grab the third operand
    uRet <- uPC, goto GetOperand            # Micro function call
    OP3Type <- uR0, OP3Val <- uR1           # Store the type bytes & value bytes for the third operand
    OP3Scale <- uR2, <No OP>                # Store the scale bytes for the third operand
    
    if OP3Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    if IR in threeOps, goto Decode          # Break loop if this is the last operand
    
    # Grab the fourth operand
    uRet <- uPC, goto GetOperand            # Micro function call
    OP4Type <- uR0, OP4Val <- uR1           # Store the type bytes & value bytes for the fourth operand
    OP4Scale <- uR2, <No OP>                # Store the scale bytes for the fourth operand
    
    if OP4Type == 0, goto InterpOperand     # If explicit end of operands, set others by default
    <No OP>, goto Decode                    # Max Nr of operands grabbed, decode

InterpOperand:
    # Control instructions
    if IR == 0x04, goto InterpDmp           # Interpret DMP operands

    # ALU instructions
    if IR == 0x10, goto InterpAdd           # Interpret ADD operands
    if IR == 0x11, goto InterpAdd           # Interpret SUB operands
    if IR == 0x15, goto InterpAdd           # Interpret AND operands
    if IR == 0x16, goto InterpAdd           # Interpret OR operands
    if IR == 0x17, goto InterpAdd           # Interpret XOR operands

    if IR == 0x12, goto InterpMul           # Interpret MUL operands
    if IR == 0x13, goto InterpDiv           # Interpret DIV operands
    if IR == 0x18, goto InterpCmp           # Interpret CMP operands

    # Memory instructions
    if IR == 0x22, goto InterpCpy           # Interpret CPY operands

    # COL instructions
    if IR == 0x34, goto InterpBeq           # Interpret BEQ operands
    if IR == 0x35, goto InterpBeq           # Interpret BNE operands
    if IR == 0x36, goto InterpBeq           # Interpret BGT operands
    if IR == 0x37, goto InterpBeq           # Interpret BGE operands

    if IR == 0x38, goto InterpBeq           # Interpret BIE operands
    if IR == 0x39, goto InterpBeq           # Interpret BDE operands

    # Failure
    <No Op>, goto halt                      # Unable to interpret these ops

InterpDmp:
    if OP1Type == 0, goto halt              # Unable to interpret DMP from 0 ops
    OP2Val <- 0, OP2Type <- 0x10            # Op2 gets an immediate 0
    <No Op>, goto Decode

InterpAdd:
    if OP1Type == 0, goto halt              # Unable to interpret ADD from 0 ops
    if OP2Type == 0, goto halt              # Unable to interpret ADD from 1 op

    OP3Type <- OP2Type, OP3Val <- OP2Val    # Op 3 <- Op 2, Op 2 <- Op 1
    OP3Scale <- OP2Scale, OP2Type <- OP1Type
    OP2Val <- OP1Val, OP1Scale <- OP2Scale
    
    <No Op>, goto Decode

InterpMul:
    if OP1Type == 0, goto halt              # Unable to interpret MUL from 0 ops
    if OP2Type == 0, goto halt              # Unable to interpret MUL from 1 op
    if OP3Type != 0, goto InterpMul1        # Branch of for interp from 3 ops

    # Interpret MUL from 2 ops
    OP4Val <- OP2Val, OP3Val <- OP1Val      # Op 3 <- Op1, Op4 <- Op2
    OP4Type <- OP2Type, OP3Type <- OP1Type  
    OP4Scale <- OP2Scale, OP3Scale <- OP1Scale

    <No Op>, goto InterpMul2

InterpMul1:
    # Interpret MUL from 3 ops
    OP4Val <- OP3Val, OP3Val <- OP2Val      # Op 3 <- Op2, Op4 <- Op3
    OP4Type <- OP3Type, OP3Type <- OP2Type  
    OP4Scale <- OP3Scale, OP3Scale <- OP2Scale

InterpMul2:
    OP2Val <- 0, OP2Type <- 0       # Op2 <- 0
    OP2Scale <- 0, <No Op>

    <No Op>, goto Decode

InterpDiv:
    if OP1Type == 0, goto halt              # Unable to interpret DIV from 0 ops
    if OP2Type == 0, goto halt              # Unable to interpret DIV from 1 op
    if OP3Type != 0, goto InterpDiv1        # Branch of for interp from 3 ops

    # Interpret DIV from 2 ops
    OP4Val <- OP2Val, OP3Val <- OP1Val      # Op 3 <- Op1, Op4 <- Op2
    OP4Type <- OP2Type, OP3Type <- OP1Type  
    OP4Scale <- OP2Scale, OP3Scale <- OP1Scale

    <No Op>, goto Decode

InterpDiv1:
    # Interpret DIV from 3 ops
    OP4Val <- OP3Val, OP3Val <- OP2Val      # Op 3 <- Op2, Op4 <- Op3
    OP4Type <- OP3Type, OP3Type <- OP2Type  
    OP4Scale <- OP3Scale, OP3Scale <- OP2Scale

    # If Op 2 is an immediate, Op 2 <- Op 4
    if OP2Type & 0xF0 == 0x10, goto InterpDiv2
    if OP2Type & 0xF0 != 0x20, goto Decode

InterpDiv2:
    OP2Val <- OP4Val, OP2Type <- OP4Type
    OP2Scale <- OP4Scale, goto Decode

InterpCmp:
    if OP1Type == 0, goto halt              # Unable to interpret CMP from 0 ops

    OP2Type <- OP1Type, OP2Val <- OP1Val    # Op 2 <- Op 1
    OP2Scale <- OP2Scale, goto Decode

InterpCpy:
    if OP1Type == 0, goto halt              # Unable to interpret CPY from 0 ops
    if OP2Type == 0, goto halt              # Unable to interpret CPY from 1 op
    if OP3Type != 0, goto InterpCpy1        # Skip to step 4 if op 3 set

    OP3Type <- 0x10, <No Op>                # Set Op 3 to a 0 immediate

InterpCpy1:
    OP4Type <- 0x10, goto Decode            # Set Op 4 to a 0 immediate

InterpBeq:
    if OP1Type == 0, goto halt              # Unable to interpret BEQ from 0 ops

    # Op 3 <- Op 2
    OP3Type <- OP2Type, OP3Val <- OP2Val
    OP3Scale <- OP2Scale, <No Op>

    # Op 2 <- 0
    OP3Type <- 0x10, goto Decode

# This microfunction will return the next operand from memory
# Returns:
#   uR0: Returns op type and prefix bytes. LSB is always the base operand type. 
#        For displacement operand, MSB is the register specifier byte (or 0). 2 
#        prefix bytes returned in displacement operands, 3 otherwise.
#
#   uR1: Returns the op value. Either immediate or register byte. For index 
#        operand, byte order is `<null> <null> <reg byte 1> <reg byte 2>`.
#
#   uR2: Returns any scale bytes (scale operand byte followed by scale reg byte).
#        Null if not a scaled operand.
#        
GetOperand:
    uR0 <- 0, uR1 <- 0                  # Clear the return registers
    uR2 <- 0, <No OP>

GetOpType:
    IncPC, IncPC                        # Halt on PC overflow, else increment
    
    MAR <- PC, <No OP>                  # Prepare to pull in the next op byte
    MDR <- Mem[MAR], uR0 <- uR0 << 0x08 # Pull next op byte, move back prefixes
    uR0 <- uR0 | MDR, <No OP>           # Insert next type byte into type buffer
    
    if MDR != 0, goto GetOpType2        # Skip if not operand terminator
    if uR0 != 0, goto halt              # Halt on Illegal operand (prefix bytes on an opcode terminator)
    uPC <- uRet, <No OP>                # Return since this is a legal terminator encoding
    
GetOpType2:
    if MDR & 0xF0 == 0, goto GetOpType  # If this was a prefix byte, grab the next byte
    <No OP>, goto FetchOpVal            # Else, decode the operand type

uRet:
    uPC <- uRet, <No OP>                # Return (No further data to grab)

FetchOpVal:
    # Break out to second stage fetch
    if MDR & 0xF0 == 0x10, goto uRet        # No more work to be done  (nybble immediate)
    
    if MDR & 0xF0 == 0x20, goto FetchOpImm  # Fetch the immediate data (for immediate value)
    if MDR & 0xF0 == 0x50, goto FetchOpImm  # Fetch the immediate data (for the pointer address)
    if MDR & 0xF0 == 0x80, goto FetchOpImm  # Fetch the immediate data (for absolute address)
    
    if MDR & 0xF0 == 0x30, goto FetchOpReg  # Fetch the register data  (for register value)
    if MDR & 0xF0 == 0x40, goto FetchOpReg  # Fetch the register data  (for indirect access)
    if MDR & 0xF0 == 0x90, goto FetchOpReg  # Fetch the register data  (for increment access) 
    if MDR & 0xF0 == 0xA0, goto FetchOpReg  # Fetch the register data  (for decrement access)
    
    if MDR & 0xF0 == 0x60, goto FetchOpIdx  # Fetch an index operand
    if MDR & 0xF0 == 0x70, goto FetchOpDsp  # Fetch a displacement operand
    if MDR & 0xF0 == 0xB0, goto FetchOpScl  # Fetch a scale operand
    
    <No OP>, goto halt                      # Halt on Invalid address mode

FetchOpImm:
    uCnt <- MDR & 0x03, <No OP>         # Set the immediate width counter

FetchOpImmLoop:
    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 0x08 # Grab next byte and prepare space for return
    uR1 <- uR1 | MDR, <No OP>           # Incorporate IMM byte into return

    if uCnt == 0, goto uRet             # Return on zero counter, else loop
    uCnt <- uCnt - 1, goto FetchOpImmLoop

FetchOpReg:
    # Skip grabbing the second byte if it isn't specified
    if MDR & 0x0C == 0x0C, goto FetchOpReg2
    uPC <- uRet, <No OP>                # Return

FetchOpReg2:
    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 0x08 # Grab next byte and prepare space for return
    uR1 <- uR1 | MDR, <No OP>           # Incorporate IMM byte into return
    
    uPC <- uRet, <No OP>                # Return

FetchOpIdx:
    # Skip grabbing the first register byte if not specified
    if uR0 & 0x0C == 0x0C, goto FetchOpIdx2
     
    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 0x08 # Grab next byte and prepare space for return
    uR1 <- MDR, <No OP>                 # Incorporate IMM byte into return
    
FetchOpIdx2:
    <No Op>, uR1 <- uR1 << 0x08
    if uR0 & 0x03 == 0x03, goto  uRet   # Skip grabbing the second reg byte if unneeded

    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], uR1 <- uR1 << 0x08 # Grab next byte and prepare space for return
    uR1 <- uR1 | MDR, <No OP>           # Incorporate IMM byte into return
    
    uPC <- uRet, <No OP>                # Return

FetchOpDsp:
    uR0 <- uR0 & 0x00FFFFFF, uCnt <- 0  # Clear the MSB of uR1 and the count (temp) register
    
    # Skip to grabbing IMM if not specified
    if MDR & 0x0C == 0x0C, goto FetchOpImm

    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], <No OP>            # Grab the register byte
    uCnt <- MDR, <No OP>                # Store the register byte into temp register
    
    uCnt <- uCnt << 0x18, <No OP>       # Shift the register byte up three bytes
    uR0 <- uR0 | uCnt, <No OP>          # Store the register byte in uR0

    <No OP>, goto FetchOpImm            # Grab the immediate for this mode

FetchOpScl:
    uR2 <- MDR, uR0 <- uR0 & 0xFFFFFF00 # Move the scale param to ur2 and clear it from uR0
    uR2 <- uR2 << 0x08, <No OP>         # Make space in ur2 for the register byte 

    if MDR & 0x03 != 0x03, goto FetchOpScl1
    
    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], <No OP>            # Grab the register byte
    uR2 <- uR2 | MDR, <No OP>           # Store the register byte into the return register

FetchOpScl1: 
    IncPC, IncPC                        # Halt on PC overflow, else increment
    MAR <- PC, <No OP>                  # Prepare to grab the next byte from data
    MDR <- Mem[MAR], <No OP>            # Grab the operand type byte
 
    if MDR & 0xF0 == 0x00, goto halt    # Fail on prefix byte
    if MDR & 0xF0 == 0xB0, goto halt    # Fail on scale of scale

    uR0 <- uR0 | MDR, goto FetchOpVal   # Store the op type byte in register, decode scaled op

